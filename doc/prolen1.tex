% sample template

\documentclass[12pt]{article}
\usepackage[spanish,es-tabla]{babel} % es-tabla changes "cuadro" to "tabla"
\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{float} % allows to place the image or tables where we want to.
\usepackage{fancyhdr}
\usepackage{vmargin}
\setlength{\parskip}{3mm} % length between paragraphs
\usepackage{subfigure} % allows to include subfigures
\setpapersize{A4} % A4 format
\usepackage{color}
\usepackage{makecell}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{Blendify: Lenguaje para la definición de simulaciones físicas}			% Title
\author{Alberto Aranda García \\ Cristian Gómez Portes \\ Daniel Pozo Romero \\ Eduardo Sánchez López}				% Author
\date{\today}				%Current  Date

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\lhead{\thetitle}
\cfoot{\thepage}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
    \includegraphics[scale = 0.15]{informatica.png}\\[1.0 cm]										% University Logo
    \textsc{\LARGE Universidad de Castilla-La Mancha\newline\newline Escuela Superior De Informática}\\[2.0 cm]		% University Name
	\textsc{\Large Memoria de Prácticas}\\[0.5 cm]												% Subject
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{center} \large
			\emph{Autores:}\\
			\theauthor\\
			\vspace*{1 cm}
			\emph{Fecha:}\\
			\thedate\\
			\end{center}
        
	\end{minipage}\\[2 cm]
	
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Presentación del problema}

Dentro de la enseñanza de Física, la visualización de los problemas es una herramienta muy importante para que los estudiantes comprendan mejor los conceptos teóricos existentes tras ellos. La teoría del aprendizaje de Ausubel\footnote{psicólogo y pedagogo estadounidense de gran importancia para el constructivismo} propone este enfoque, ya que permite al alumno esclarecer y dotar de utilidad aquello que está aprendiendo \cite{ausubel1983teoria}. En este contexto, la simulación es una opción que lleva disponible durante años, pero que está siendo muy infrautilizada.

Esto tiene una fácil explicación: la mayoría de programas de generación de simulaciones físicas imponen interfaces gráficas que requieren una inversión de tiempo grande por parte del usuario: partiendo de un enunciado textual de un problema, el usuario, que puede ser tanto un profesor como un estudiante de física, se ve obligado a traducirlo manualmente a un formato gráfico, lidiando muchas veces con interfaces de usuario tediosas que hacen perder mucho tiempo, tanto para aprenderlas, como por las operaciones repetitivas que deben realizarse. 

Lo ideal sería que, a partir de un enunciado de un problema, fuese posible la generación automática de su simulación. Dejando de lado las dificultades que el Procesado de Lenguaje Natural supone (aún dentro de un dominio tan acotado), una primera aproximación puede ser la creación de un lenguaje con un poder expresivo similar al de los enunciados de problemas, al que sea lo más sencillo posible traducir (para un humano) dichos enunciados escritos originalmente en lenguaje natural.

Como plataforma de simulaciones físicas, vamos a considerar Blender, ya que incorpora, entre muchas otras funcionalidades, un motor de físicas muy potente, y, tantoo más importante, una API para Python que expone prácticamente todas las funcionalidades del programa.

Para nuestra práctica, por tanto, consideramos la definición de un lenguaje que permita escribir simulaciones físicas, y la construcción de un procesador de lenguajes que lo traduzca a código Python que use la API de Blender, que posteriormente podrá ser interpretado por este programa para generar una simulación. Nuestro objetivo principal, pues, es simplificar al máximo posible la generación de simulaciones que de otra forma serían muy tediosas de realizar.

\section{Descripción del lenguaje}

Como se ha dicho anteriormente, nuestro lenguaje, llamado \textbf{Blendify}, deberá tener el mismo poder expresivo los enunciados de problemas, y posiblemente, permitir definir ciertos hechos sobre el contexto que se dan por supuesto (tipo de problema, dimensionalidad, etc.). Si analizamos la estructura de los enunciados, nos encontramos con que, primero, se nos da información sobre los elementos que intervienen en el problema (cubo, esfera, polea, rampa, electrón, planeta…) y sus parámetros (masa, velocidad, fuerzas que actúan sobre este…); posteriormente, se suele dar una condición que podemos considerar como de parada de la simulación, y una pregunta (que podemos felizmente obviar) sobre algún parámetro de un elemento en determinado momento. Nuestro lenguaje, pues, deberá permitir declarar diferentes objetos y sus correspondientes atributos, así como ciertos parámetros globales que afecten a toda la simulación, alguna condición de parada, y posiblemente, información sobre qué quiere hacer el usuario con la simulación (ejecutarla, generar una animación, etc.).

\subsection{Tabla de Tokens}

En esta sección se muestra la tabla de \textit{tokens} que componen le vocabulario de nuestro lenguaje ---  ver Tabla \ref{tab:Tokens}. Esta tabla nos ayudará a formar las producciones que generarán nuestro lenguaje final. En el siguiente apartado se podrá ver como se ha hecho uso de estos \textit{tokens} en las diferentes producciones.

\begin{table}
\centering
\begin{tabular}{| c | c | c |} \hline
\textbf{Tokens}            & \textbf{Lexeme} &  \textbf{Pattern} \\\hline
Assign            &   =     & =        \\\hline
Comma             & ,       & ,        \\\hline
Open Bracket           & \{       & \{        \\\hline
Closed Bracket           & \}       & \}       \\\hline
Case              &  Case      & Case        \\\hline
scene             & scene       & scene        \\\hline
start\_simulation & start\_simulation       & start\_simulation        \\\hline
condition         & AND \textbar OR       & AND \textbar OR        \\\hline
Open parenthesis       & (       & (        \\\hline
Closed parenthesis       & )       & )        \\\hline
Type Figure       & static, dynamic       & static, dynamic        \\\hline
Type Value        &  \makecell{position, rotation, scale \\ weight, speed}    & \makecell{position \textbar rotation \textbar scale \\\textbar weight \textbar speed}        \\\hline
From Figure       & \makecell{Cube, Sphere, Cone \\ Cylinder, Force\_field, Ramp}       & \makecell{Cube \textbar Sphere \textbar Cone \\ Cylinder \textbar Force\_field \textbar Ramp}        \\\hline
Coordinates       & (1.2, 1.2, 1.2)       & '(' real ',' real ',' real ')'        \\\hline
Alphabetic        & a ,…, z , A ,…, Z       &  lower\_case \textbar  upper\_case       \\\hline
lower\_case        & a ,..., z       & [a-z] \\\hline
upper\_case        & A ,..., Z       & [A-Z] \\\hline
Real              & 23.21       &  digit + [('.' digit + )]        \\\hline
Digit            & 0 ,…, 9       & \makecell{1 \textbar 2 \textbar 3 \textbar 4 \textbar 5 \\ 6 \textbar 7 \textbar 8 \textbar 9 \textbar 0}        \\\hline
\end{tabular}
\caption{\label{tab:Tokens}Tabla de tokens.}
\end{table}

\subsection{EBNF}

Una vez tenemos definidos nuestros \textit{tokens}, podemos comenzar a especificar nuestro lenguaje. Como producción de partida se ha pensado en una que contenga terminales simples para que el usuario (normalmente destinado a aquellos que no tiene mucha experiencia en el campo de la programación) no tenga dificultades a la hora de crear diferentes escenarios, ya que la herramienta está pensada para ayudar en el campo de la física. La producción sería la siguiente: \\ \\
\noindent \textit{program} ::= \textbf{begin} id\_program body\_program \textbf{end}.

Se pretende que el usuario define el comienzo y el fin del programa para ayudarle a no cometer errores que puedan entorpecer el desarrollo del mismo.

\noindent \textit{body\_program} ::= \textbf{declaration} body\_declaration \textbf{scene} body\_scene \textbf{action} body\_action.

Como se ha mencionado anteriormente, el objetivo de esta producción sería el mismo, ya que hay una parte de declaración de variables, otra de escenarios y acciones.

\noindent\textit{body\_declaration} ::= '\{' \{ \textbf{(static} attribute\_declaration '=' value\_static) \textbar (\textbf{dynamic} attribute\_declaration '=' value\_dynamic)\}  '\}'.

\noindent \textit{body\_action} ::= '\{' \textbf{start\_simulation} '\}'.

\noindent \textit{body\_scene} ::= '\{' \{(attribute\_case '=' goal)\} '\}'.

Estas tres producciones defininen los campos de declaraciones, acciones y escenearios. Básicamente, lo que haremos en estos apartados será definir un tipo, el cual irá aosciado a un identificador. Por ejemplo, en el caso de \textit{body\_declaration} definiremos si las variables son estáticas (objetos que tendrán posición, rotación y escala) o dinámicas (objetos que tendrán velocidad y peso, además de las mencionadas anteriormente), además de especificar su tipo e identificador. En el caso de \textit{body\_scene} sería lo mismo obviando \textbf{static} y \textbf{dynamic}.

\noindent \textit{attribute\_declaration} ::= type\_figure id\_attribute.

\noindent \textit{type\_figure} ::= \textbf{Cube} \textbar \textbf{Sphere} \textbar \textbf{Cone} \textbar \textbf{Cylinder} \textbar \textbf{Force\_field} \textbar \textbf{Ramp} \textbar  \textbf{Plane}.

Estas tres ultimas producciones son aquellas que definen los tipos de figuras que podremos especificar: \textbf{Cube}, \textbf{Sphere}, \textbf{Cone}, \textbf{Cylinder}, \textbf{Force\_field}, \textbf{Ramp}, \textbf{Plane}. Además, el identificador que será posible concretar serán aquellos que comiencen por letra, sin distinción entre minúsculas y mayúsculas, seguido de letras o números.

\noindent \textit{attribute\_case} := \textbf{Case} id\_case.

Aunque se ha mencionado anteriormente, \textit{attribute\_case} define el tipo del escenario que va a ser creado.  \textbf{Case} es una palabra reservada que hace mención al tipo de variable escenario. \textit{id\_case} concreta el nombre que tendrá un escenario en concreto. La formación de \textit{id\_case} será el mismo que \textit{id\_attribute}.

\noindent \textit{goal}::=  gplane \textbar gspeed \textbar gcollision \textbar goal2.

\noindent \textit{goal2} ::= '(' goal \{ condition goal \} ')'.

\textit{goal} y \textit{goal2} nos permitirán crear condiciones a la hora de crear escenearios. Con estas producciones podremos definir una o diferentes metas que ayudarán al usuario a tener diferentes punto de vista de su problema.

\noindent \textit{value\_static} ::= [position] [rotation] [scale].

\noindent \textit{value\_dynamic} ::= [position] [rotation] [scale] [weight] [speed].

\textit{value\_static} y \textit{value\_dynamic} serán aquellas producciones que permitan definir si un objeto será estático, es decir, no podrá moverse, o dinámico, tendrá una velocidad y peso asociados.

\noindent \textit{id\_attribute} ::= alphabetic \{alphanumeric\}.

\noindent \textit{id\_program} ::= alphabetic \{alphanumeric\}.

\noindent \textit{position} ::= \textbf{position} coordinates.

\noindent \textit{rotation} ::= \textbf{rotation} coordinates.

\noindent \textit{scale} ::=  \textbf{scale} coordinates.

\noindent \textit{weight} ::= \textbf{weight} real.

\noindent \textit{speed} ::= \textbf{speed} coordinates.

Con estas 5 producciones se intenta definir la posición, rotación, escala, peso y velocidad de un objeto en un escenario específico. Todas ellas se formarán mediante coordenadas (conjunto de 3 valores definidos por los ejes 'x', 'y', 'z' especificado en \textit{coordinates}) menos el peso, que será un número real.

\noindent \textit{coordinates} ::= '(' real ',' real ','  real ')'.

\noindent \textit{condition} ::= \textbf{AND} \textbar \textbf{OR}.

\textit{condition} producción que contiene las condiciones lógicas \textbf{AND} y \textbf{OR}.

\noindent \textit{alphabetic} ::= lower\_case  \textbar  upper\_case.

\noindent \textit{lower\_case} ::= [a-z].

\noindent \textit{upper\_case} ::=[A-Z].

\textit{alphabetic} es aquella producción que genera letras minúsculas debido a \textit{lower\_case} y letras mayúsculas debido a \textit{upper\_case}.

\noindent \textit{alphanumeric} ::= alphabetic \textbar digit.

\textit{alphanumeric} será la producción que genere tanto letras, minúsculas o mayúsculas, como dígitos.

\noindent \textit{real} ::= digit + [('.' digit + )].

Finalmente, \textit{real} será aquella producción que permita generar números reales.

\newpage
\bibliographystyle{plain}
\bibliography{biblist}

\end{document}